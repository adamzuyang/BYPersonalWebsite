{
    "pathfinder_welcome": "Welcome to the Sorting Visualizer!",

    "algorithmsIntro": "Know Your Algorithms",

    "algorithms": [
        {
            "name": "Selection Sort",
            "id": "selection",
            "description": "A comparison-based algorithm that finds the smallest element of the unsorted portion of the array and places it at the end of the sorted portion. A fairly slow algorithm that runs in &Theta;(N<sup>2</sup>) time, where N represents the size of the array. This sort is not stable."
        },
        {
            "name": "Heap Sort",
            "id": "heap",
            "description": "A comparison-based algorithm that uses a max-heap to sort a given array. Runs in O(N*log(N)) time, where N represents the size of the array, but can achieve a runtime of &Theta;(N) if given an array of duplicates. This sort is not stable."
        },
        {
            "name": "Merge Sort",
            "id": "merge",
            "description": "A comparison-based algorithm that first recursively merge sorts the two halves of the array and then merges those two halves together to form a sorted array. Runs in &Theta;(N*log(N)) time, where N is the size of the array, but requires &Theta;(N) memory to maintain an auxiliary array. This sort is stable."
        },
        {
            "name": "Insertion Sort",
            "id": "insertion",
            "description": "A comparison-based algorithm that, for all elements of the array, swaps each element towards the front of the array until all elements before the given element are smaller than that given element. Runs in &Omega;(N) and O(N<sup>2</sup>) time, where N is the size of the array. Insertion sort is unique in that its runtime is proportional to the number of \"inversions\" in the array. Given K inversions, the runtime of insertion sort is &Theta;(N+K). This sort is stable."
        },
        {
            "name": "Quick Sort",
            "id": "quick",
            "description": "A comparison-based algorithm that first partitions the given array into two sub-arrays based on a \"pivot\" and then recursively sorts the two sub-arrays. The partitioning algorithm used for this implementation of Quick Sort is Tony Hoare's partitioning scheme. Despite having a runtime of &Omega;(N*log(N)) and O(N<sup>2</sup>), where N is the size of the array, it is empirically the fastest comparison-based sort on average. Due to the way this implementation of Quick Sort partitions an array, this sort is not stable. However, there are stable variations of Quick Sort."
        },
        {
            "name": "LSD Radix Sort",
            "id": "lsd",
            "description": "A radix sort that sorts the array in order of magnitude from the least significant digit. Its runtime is &Theta;(WN+WR), where N is the array size, R is the size of the alphabet (in this case 10), and W is the number of digits in the longest element of the array. This sort is stable."
        },
        {
            "name": "MSD Radix Sort",
            "id": "msd",
            "description": "Similar to LSD radix sort, MSD radix sort sorts the array in order of magnitude from the most significant digit. Its runtime is better than that of LSD radix sort in certain cases. MSD radix sort has runtime &Theta;(N+R) in the best case and &Theta;(WN+WR) in the worst case, where N is the array size, R is the size of the alphabet (in this case 10), and W is the number of digits in the longest element of the array. This sort is stable."
        }
    ],

    "instructionsIntro": "Getting Started",
    
    "instructions": [
        {
            "text": "Select an algorithm...",
            "list": []
        },
        {
            "text": "...and then press \"Visualize!\"",
            "list": [
                {"text": "Red bars indicate the values currently being compared."}
            ]
        },
        {
            "text": "To reset the array or generate a new one, simply click \"Generate New Array.\"",
            "list": []
        },
        {
            "text": "If the visualizer is too fast or slow, you can also change the animation speed.",
            "list": []
        },
        {
            "text": "To re-open this welcome screen, click \"Intro.\"",
            "list": []
        }
    ]
}