<!DOCTYPE html>
<html>
<head>
<title>Lecture17.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="lecture-17-b-trees-2-3-2-3-4-trees">Lecture 17: B-Trees (2-3, 2-3-4 Trees)</h1>
<h4 id="1052020">10/5/2020</h4>
<h2 id="bst-tree-height">BST Tree Height</h2>
<h3 id="bst-tree-height">BST Tree Height</h3>
<ul>
<li>Trees range from best-case &quot;bushy&quot; to worst-case &quot;spindly&quot;
<ul>
<li>Height varies dramatically among the two
<ul>
<li>Theta(log N) for bushy vs Theta(N) for spindly</li>
</ul>
</li>
</ul>
</li>
<li>Performance of operations on spindly trees can be just as bad as a linked list!</li>
<li>A worst case (spindly tree) has a height that grows exactly linearly - Theta(N)</li>
<li>A best case (bushy tree) has a tree height that grows exactly logarithmically - Theta(log N)</li>
</ul>
<h3 id="the-usefulness-of-big-o">The Usefulness of Big O</h3>
<ul>
<li>Big O is a useful idea:
<ul>
<li>Allows us to make simple blanket statements, e.g. can just say &quot;binary search is O(log N)&quot; instead of &quot;binary search is Theta(log N) in the worst case&quot;</li>
<li>Sometimes don't know the exact runtime, so use O to give an upper bound
<ul>
<li>Example: Runtime for finding shortest route that goes to all world cities is O(2^N). There might be a faster way, but nobody knows one yet</li>
</ul>
</li>
<li>Easier to write proofs for Big O than Big Theta, e.g. finding runtime of mergesort, you can round up the number of items to the next power of 2. A little beyond the scope of the course.</li>
</ul>
</li>
</ul>
<h2 id="height-depth-and-performance">Height, Depth, and Performance</h2>
<h3 id="height-and-depth">Height and Depth</h3>
<ul>
<li>Height and average depth are important properties of BSTs
<ul>
<li>The <strong>&quot;depth&quot; of a node</strong> is how far it is from the root
<ul>
<li>The root has depth 0</li>
</ul>
</li>
<li>The <strong>&quot;height&quot; of a tree</strong> is the depth of its deepest leaf</li>
<li>The <strong>&quot;average depth&quot;</strong> of a tree is the average depth of a tree's nodes</li>
</ul>
</li>
</ul>
<h3 id="height-depth-and-runtime">Height, Depth, and Runtime</h3>
<ul>
<li>Height and average depth determine runtimes for BST operations
<ul>
<li>The <strong>&quot;height&quot;</strong> of a tree determines the worst case runtime to find a node</li>
<li>The <strong>&quot;average depth&quot;</strong> determines the average case runtime to find a node</li>
</ul>
</li>
</ul>
<h3 id="important-question-what-about-real-world-bsts">Important Question: What about real world BSTs?</h3>
<ul>
<li>BSTs have:
<ul>
<li>Worst case Theta(N) height</li>
<li>Best case Theta(log N) height</li>
</ul>
</li>
<li>One way to approximate real world BSTs is to consider randomized BSTs</li>
<li><strong>Nice Property</strong>. Random trees have Theta(log N) average depth and height
<ul>
<li>In other words: Random trees are bushy, not spindly</li>
</ul>
</li>
</ul>
<h3 id="randomized-trees-mathematical-analysis">Randomized Trees: Mathematical Analysis</h3>
<ul>
<li><strong>Average Depth</strong>. If N distinct keys are inserted into a BST, the expected average depth is ~ 2 ln N
<ul>
<li>Thus, average runtime for contains operation is Theta(log N) on a tree built with random inserts</li>
</ul>
</li>
<li><strong>Tree Height</strong>. If N distinct keys are inserted in random order, expected tree height is ~ 4.311 ln N
<ul>
<li>Thus, worst case runtime for contains operation is Theta(log N) on a tree built with random inserts</li>
</ul>
</li>
<li>BSTs have:
<ul>
<li>Worst case Theta(N) height</li>
<li>Best case Theta(log N) height</li>
<li>Theta(log N) height if constructed via random inserts</li>
</ul>
</li>
<li>In real world applications we expect both insertion and deletion
<ul>
<li>Can show that random trees including deletion are still Theta(log N) height</li>
</ul>
</li>
</ul>
<h3 id="good-news-and-bad-news">Good News and Bad News</h3>
<ul>
<li>Good news: BSTs have great performance if we insert items randomly
<ul>
<li>Performance is Theta(log N) per operation</li>
</ul>
</li>
<li>Bad news: We can't always insert our items in a random order
<ul>
<li>Data comes in over time, don't have all at once</li>
</ul>
</li>
</ul>
<h2 id="b-trees--2-3-trees--2-3-4-trees">B-trees / 2-3 trees / 2-3-4 trees</h2>
<h3 id="avoiding-imbalance-through-overstuffing">Avoiding Imbalance through Overstuffing</h3>
<ul>
<li>The problem is adding new leaves at the bottom</li>
<li>Crazy idea: never add new leaves at the bottom
<ul>
<li>Tree can never get imbalanced</li>
</ul>
</li>
<li>Avoid new leaves by &quot;overstuffing&quot; the leaf nodes
<ul>
<li>&quot;Overstuffed tree&quot; always has balanced height, because leaf depths never change</li>
</ul>
</li>
<li>Overstuffed trees are a logically consistent but very weird data structure
<img src="images/17.1.png" alt="">
<ul>
<li>contains(18):
<ul>
<li>18 &gt; 13? Yes, go right</li>
<li>18 &gt; 15? Yes, go right</li>
<li>16 = 18? No</li>
<li>17 = 18? No</li>
<li>18 = 18? Yes! Found it</li>
</ul>
</li>
<li>Problem with this idea? Degenerates into linked list</li>
</ul>
</li>
</ul>
<h3 id="revising-our-overstuffed-tree-approach-moving-items-up">Revising Our Overstuffed Tree Approach: Moving Items Up</h3>
<ul>
<li>Height is balanced, but we have a new problem
<ul>
<li>Leaf nodes can get too juicy</li>
</ul>
</li>
<li>Solution?
<ul>
<li>Set a limit L on the number of items, say L=3</li>
<li>If any node has more than L items, give an item to parent
<ul>
<li>Which one? Let's say (arbitrarily) the left-middle</li>
</ul>
</li>
</ul>
</li>
<li>What's the problem now?
<ul>
<li>16 is to the right of 17
<img src="images/17.2.png" alt="">
<img src="images/17.3.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="revising-overstuffed-tree-approach-node-splitting">Revising Overstuffed Tree Approach: Node Splitting</h3>
<ul>
<li>Solution?
<ul>
<li>Set a limit L on the number of items, say L=3</li>
<li>If any node has more than L items, give an item to parent
<ul>
<li>Pulling item out of full node splits it into left and right</li>
<li>Parent node now has three children!</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="images/17.4.png" alt=""></p>
<ul>
<li>This is a logically consistent and not so weird data structure
<ul>
<li>Contains(18):
<ul>
<li>18 &gt; 13, so go right</li>
<li>18 &gt; 15, so compare vs. 17</li>
<li>18 &gt; 17, so go right</li>
</ul>
</li>
</ul>
</li>
<li>Examining a node costs us O(L) compares, but that's OK since L is constant</li>
<li>What if a non=leaf node gets too full? Can we split that?</li>
</ul>
<h3 id="add-chain-reaction">add: Chain Reaction</h3>
<ul>
<li>Suppose we add 25, 26:</li>
</ul>
<p><img src="images/17.5.png" alt=""></p>
<h3 id="what-happens-if-the-root-is-too-full">What Happens if the root is too full?</h3>
<p><img src="images/17.6.png" alt=""></p>
<h3 id="perfect-balance">Perfect Balance</h3>
<ul>
<li>Observation: Splitting-trees have perfect balance
<ul>
<li>If we split the root, every node gets pushed down by exactly one level</li>
<li>If we split a leaf or internal node, the height doesn't change</li>
</ul>
</li>
<li>All operations have guaranteed O(log N) time</li>
</ul>
<h3 id="the-real-name-for-splitting-trees-is-%22b-trees%22">THe Real Name for Splitting Trees is &quot;B Trees&quot;</h3>
<ul>
<li>B-trees of order L=3 (like we used today) are also called a 2-3-4 tree or a 2-4 tree
<ul>
<li>&quot;2-3-4&quot; refers to the number of children that a node can have</li>
</ul>
</li>
<li>B-trees of order L=2 are also called a 2-3 tree</li>
<li>B-Trees are most popular in two specific contexts:
<ul>
<li>Small L(L=2 or L=3)
<ul>
<li>Used as a conceptually simple balanced search tree</li>
</ul>
</li>
<li>L is very large (say thousands)
<ul>
<li>Used in practice for databases and file systems</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="b-tree-bushiness-invariants">B-tree Bushiness Invariants</h2>
<h3 id="exercise">Exercise</h3>
<ul>
<li>No matter the insertion order you choose, resulting B-Tree is always bushy!
<ul>
<li>May vary in height a little bit, but overall guaranteed to be bushy</li>
</ul>
</li>
</ul>
<h3 id="b-tree-invariants">B-Tree Invariants</h3>
<ul>
<li>Because of the way B-Trees are constructed, we get two nice invariants
<ul>
<li>All leaves must be the same distance from the source</li>
<li>A non-leaf node with k items must have exactly k+1 children</li>
</ul>
</li>
<li>These invariants guarantee that our tree will be bushy</li>
</ul>
<h2 id="b-tree-runtime-analysis">B-Tree Runtime Analysis</h2>
<h3 id="height-of-a-b-tree-with-limit-l">Height of a B-Tree with Limit L</h3>
<ul>
<li>L: Max number of items per node</li>
<li>Height: Between ~log_{L+1}(N) and ~log_2(N)
<ul>
<li>Largest possible height is all non-leaf nodes have 1 item</li>
<li>Smallest possible height is all nodes have L items</li>
<li>Overall height is therefore Theta(log N)</li>
</ul>
</li>
</ul>
<h3 id="runtime-for-contains">Runtime for <code>contains</code></h3>
<ul>
<li>Runtime or contains:
<ul>
<li>Worst case number of nodes to inspect: H + 1</li>
<li>Worst case number of items to inspect per node: L</li>
<li>Overall runtime: O(HL)</li>
</ul>
</li>
<li>Since H = Theta(log N), overall runtime is O(L log N)
<ul>
<li>Since L is a constant, runtime is therefore O(log N)</li>
</ul>
</li>
<li>Bottom line: contains and add are both O(log N)</li>
</ul>
<h2 id="summary">Summary</h2>
<h3 id="summary">Summary</h3>
<ul>
<li>BSTs have best case height Theta(log N) and worst case height Theta(N)
<ul>
<li>Big O is not the same thing as worst case</li>
</ul>
</li>
<li>B-Trees are a modification of the binary search tree that avoids Theta(N) worst case
<ul>
<li>Nodes may contain between 1 and L items</li>
<li><code>contains</code> works almost exactly like a normal BST</li>
<li><code>add</code> works by adding items to existing leaf nodes
<ul>
<li>If nodes are too full, they split</li>
</ul>
</li>
<li>Resulting tree has perfect balance. Runtime for operations is O(log N)</li>
<li>Have not discussed deletion</li>
<li>Have not discussed how splitting works if L &gt; 3</li>
<li>B-trees are more complex, but they can efficiently handle ANY insertion order</li>
</ul>
</li>
</ul>

</body>
</html>
