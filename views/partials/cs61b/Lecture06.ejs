<!DOCTYPE html>
<html>
<head>
<title>Lecture06.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="lecture-6-alists-resizing-vs-slists">Lecture 6: ALists, Resizing, vs. SLists</h1>
<h4 id="992020">9/9/2020</h4>
<h2 id="a-last-look-at-linked-lists">A Last Look at Linked Lists</h2>
<h3 id="doubly-linked-lists">Doubly Linked Lists</h3>
<ul>
<li>Through various improvements, we made all of the following operations fast:
<ul>
<li><code>addFirst, addLast</code></li>
<li><code>getFirst, getLast</code></li>
<li><code>removeFirst, removeLast</code></li>
</ul>
</li>
</ul>
<h3 id="arbitrary-retrieval">Arbitrary Retrieval</h3>
<ul>
<li>Suppose we added <code>get(int i)</code>, which returns the ith item from the list</li>
<li>Why would <code>get</code> be slow for long lists compared to <code>getLast()</code>? For what inputs?
<ul>
<li>Have to scan to desired position. Slow for any <code>i</code> not near the sentinel node</li>
<li>How to fix this?</li>
<li>For now: We'll take a different tack: Using an array instead (no links!)</li>
</ul>
</li>
</ul>
<h2 id="naive-array-lists">Naive Array Lists</h2>
<h3 id="random-access-in-arrays">Random Access in Arrays</h3>
<ul>
<li>Retrieval from any position of an array is very fast
<ul>
<li>Independent of array size</li>
<li>61C Preview: Ultra fast random access results from the fact that memory boxes are the same size (in bits)</li>
</ul>
</li>
</ul>
<h3 id="our-goal-alistjava">Our Goal: AList.java</h3>
<ul>
<li>Want to figure out how to build an array version of a list:
<ul>
<li>In lecture we'll only do back operations</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>public class AList {
    private int[] items;
    private int size;

    /** Creates an empty list. */
    public AList() {
        items = new int[100];
        size = 0;
    }

    /** Inserts X into the back of the list */
    public void addLast(int x) {
        items[size] = x;
        size = size + 1;
    }

    /** Returns the item from the back of the list. */
    public int getLast() {
        return items[size-1];
    }

    /** Gets the ith item from the List (0 is the front) */
    public int get(int i) {
        return items[i];
    }
    
    /** Returns the number of items in the list. */
    public int size() {
        return size;
    }
}
</div></code></pre>
<h3 id="naive-alist-code">Naive AList Code</h3>
<ul>
<li>AList Invariants:
<ul>
<li>The position of the next item to be inserted is always <code>size</code></li>
<li><code>size</code> is always the number of items in the AList</li>
<li>The last item in the list is always in position <code>size - 1</code></li>
</ul>
</li>
<li>Let's now discuss delete operations</li>
</ul>
<h3 id="the-abstract-vs-the-concrete">The Abstract vs. the Concrete</h3>
<ul>
<li>When we <code>removeLast()</code>, which memory boxes need to change? To what?
<ul>
<li>User's mental model: {5, 3, 1, 7, 22, -1} -&gt; {5, 3, 1, 7, 22}</li>
</ul>
</li>
<li>Actual truth:
<ul>
<li>We change the size</li>
</ul>
</li>
</ul>
<h3 id="deletion">Deletion</h3>
<ul>
<li>When we <code>removeLast()</code>, which memory boxes need to change? To what?
<ul>
<li>Only <code>size</code>!</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>public class AList {
    private int[] items;
    private int size;

    /** Creates an empty list. */
    public AList() {
        items = new int[100];
        size = 0;
    }

    /** Inserts X into the back of the list */
    public void addLast(int x) {
        items[size] = x;
        size = size + 1;
    }

    /** Returns the item from the back of the list. */
    public int getLast() {
        return items[size-1];
    }

    /** Gets the ith item from the List (0 is the front) */
    public int get(int i) {
        return items[i];
    }
    
    /** Returns the number of items in the list. */
    public int size() {
        return size;
    }

    /** Deletes item from back of the list and returns deleted item */
    public int removeLast() {
        int x = getLast();
        items[size-1] = 0; // Not necessary to preserve invariants -&gt; not necessary for correctness
        size = size - 1;
        return x;
    }
}
</div></code></pre>
<h2 id="resizing-arrays">Resizing Arrays</h2>
<h3 id="the-mighty-alist">The Mighty AList</h3>
<ul>
<li>Key Idea: Use some subset of the entries of an array</li>
<li>What happens if we insert more than 100 items in AList? What should we do about it?</li>
</ul>
<h3 id="array-resizing">Array Resizing</h3>
<ul>
<li>When the array gets too full, e.g. addLast(11), just make a new array:
<ul>
<li><code>int[] a = new int[size+1];</code></li>
<li><code>System.arraycopy()</code></li>
<li><code>a[size] = 11;</code></li>
<li><code>items = a; size += 1;</code></li>
</ul>
</li>
<li>We call this process &quot;resizing&quot;</li>
</ul>
<h3 id="implementation">Implementation</h3>
<ul>
<li>Let's implement the resizing capability</li>
</ul>
<pre class="hljs"><code><div>public class AList {
    private int[] items;
    private int size;

    /** Creates an empty list. */
    public AList() {
        items = new int[100];
        size = 0;
    }

    /** Resizes the underlying array to the target capacity */
    private void resize(int capacity) {
        int[] a = new int[capacity]
        System.arraycopy(items, 0, a, 0, size);
        items = a;
    }

    /** Inserts X into the back of the list */
    public void addLast(int x) {
        if (size == items.length) {
            resize(size + 1);
        }
        items[size] = x;
        size = size + 1;
    }

    /** Returns the item from the back of the list. */
    public int getLast() {
        return items[size-1];
    }

    /** Gets the ith item from the List (0 is the front) */
    public int get(int i) {
        return items[i];
    }
    
    /** Returns the number of items in the list. */
    public int size() {
        return size;
    }

    /** Deletes item from back of the list and returns deleted item */
    public int removeLast() {
        int x = getLast();
        items[size-1] = 0; // Not necessary to preserve invariants -&gt; not necessary for correctness
        size = size - 1;
        return x;
    }
}
</div></code></pre>
<h2 id="basic-resizing-analysis">Basic Resizing Analysis</h2>
<h3 id="runtime-and-space-usage-analysis">Runtime and Space Usage Analysis</h3>
<ul>
<li>Suppose we have a full array of size 100. If we can <code>addLast</code> two times, how many total array memory boxes will we need to create and fill?
<ul>
<li>Answer: 203</li>
</ul>
</li>
</ul>
<h3 id="array-resizing">Array Resizing</h3>
<ul>
<li>Resizing twice requires us to create and fill 203 total memory boxes
<ul>
<li>Most boxes at any one time is 203</li>
</ul>
</li>
</ul>
<h3 id="runtime-and-space-usage-analysis">Runtime and Space Usage Analysis</h3>
<ul>
<li>Suppose we have a full array of size 100. If we call <code>addLast</code> until <code>size = 1000</code>, roughly how many total memory boxes will we need to create and fill?
<ul>
<li>Answer: 101 + 102 + ... + 1000 = approximately 500000</li>
</ul>
</li>
</ul>
<h3 id="resizing-slowness">Resizing Slowness</h3>
<ul>
<li>Inserting 100,000 items requires rought 5,000,000,000 new containers
<ul>
<li>Computers operate at the speed of GHz</li>
<li>No huge surprise that 100,000 items took seconds</li>
</ul>
</li>
<li>Our resizing for ALists is done in linear time</li>
</ul>
<h2 id="making-alist-fast">Making AList Fast</h2>
<h3 id="fixing-the-resizing-performance-bug">Fixing the Resizing Performance Bug</h3>
<ul>
<li>How do we fix this?</li>
</ul>
<pre class="hljs"><code><div>public class AList {
    private int[] items;
    private int size;

    /** Creates an empty list. */
    public AList() {
        items = new int[100];
        size = 0;
    }

    /** Resizes the underlying array to the target capacity */
    private void resize(int capacity) {
        int[] a = new int[capacity]
        System.arraycopy(items, 0, a, 0, size);
        items = a;
    }

    /** Inserts X into the back of the list */
    public void addLast(int x) {
        if (size == items.length) {
            resize(size * 2); // A subtle fix!!!
        }
        items[size] = x;
        size = size + 1;
    }

    /** Returns the item from the back of the list. */
    public int getLast() {
        return items[size-1];
    }

    /** Gets the ith item from the List (0 is the front) */
    public int get(int i) {
        return items[i];
    }
    
    /** Returns the number of items in the list. */
    public int size() {
        return size;
    }

    /** Deletes item from back of the list and returns deleted item */
    public int removeLast() {
        int x = getLast();
        items[size-1] = 0; // Not necessary to preserve invariants -&gt; not necessary for correctness
        size = size - 1;
        return x;
    }
}
</div></code></pre>
<h3 id="probably-surprising-fact">(Probably) Surprising Fact</h3>
<ul>
<li>Geometric resizing is much faster: Just how much better will have to wait</li>
</ul>
<pre class="hljs"><code><div>    public void addLast(int x) {
        if (size == items.length) {
            resize(size * 2); // A subtle fix!!!
        }
        items[size] = x;
        size = size + 1;
    }
</div></code></pre>
<ul>
<li>This is how Python lists are implemented</li>
</ul>
<h3 id="performance-problem-2">Performance Problem #2</h3>
<ul>
<li>Suppose we have a very rare situation occurs which causes us to:
<ul>
<li>Insert 1,000,000,000 items</li>
<li>Then remove 990,000,000 items</li>
</ul>
</li>
<li>Our data structure will handle this spike of evens as well as it could, but afterwards there is a problem</li>
</ul>
<h3 id="memory-efficiency">Memory Efficiency</h3>
<ul>
<li>An AList should not only be efficient in time, but also efficient in space
<ul>
<li>Define the &quot;usage ratio&quot; R = size / items.length;</li>
<li>Typical solution: Half array size when R &lt; 0.25</li>
<li>More details in a few weeks</li>
</ul>
</li>
<li>Later we will consider tradeoffs between time and space efficiency for a variety of algorithms and data structures</li>
</ul>
<h2 id="generic-alist">Generic AList</h2>
<h3 id="theres-a-problem">There's a Problem</h3>
<ul>
<li>Generic arrays are not allowed :((</li>
<li>Here's our fix</li>
</ul>
<pre class="hljs"><code><div>public class AList&lt;Item&gt; {
    private Item[] items;
    private int size;

    /** Creates an empty list. */
    public AList() {
        items = (Item[]) new Object[100];
        size = 0;
    }

    /** Resizes the underlying array to the target capacity */
    private void resize(int capacity) {
        Item[] a = (Item[]) new Object[capacity]
        System.arraycopy(items, 0, a, 0, size);
        items = a;
    }

    /** Inserts X into the back of the list */
    public void addLast(int x) {
        if (size == items.length) {
            resize(size * 2); // A subtle fix!!!
        }
        items[size] = x;
        size = size + 1;
    }

    /** Returns the item from the back of the list. */
    public Item getLast() {
        return items[size-1];
    }

    /** Gets the ith item from the List (0 is the front) */
    public Item get(int i) {
        return items[i];
    }
    
    /** Returns the number of items in the list. */
    public int size() {
        return size;
    }

    /** Deletes item from back of the list and returns deleted item */
    public Item removeLast() {
        int x = getLast();
        items[size-1] = null;
        size = size - 1;
        return x;
    }
}
</div></code></pre>
<h3 id="generic-alists-similar-to-generic-slists">Generic ALists (similar to generic SLists)</h3>
<ul>
<li>When creating an array of references to Glorps:
<ul>
<li><code>(Glorp[]) new Object[cap];</code></li>
<li>Causes a compiler warning, which you should ignore</li>
</ul>
</li>
<li>Why not just <code>new Glorp[cap]</code>
<ul>
<li>Will cause a &quot;generic array creation&quot; error</li>
</ul>
</li>
</ul>
<h3 id="nulling-out-deleted-items">Nulling Out Deleted Items</h3>
<ul>
<li>Unlike integer based ALists, we actually want to null out deleted items
<ul>
<li>Java only destroys unwanted objects when the last reference has been lost</li>
<li>Keeping references to unneeded objects is sometimes called loitering</li>
<li>Save memory. Don't loiter</li>
</ul>
</li>
</ul>

</body>
</html>
